# Scenario-ai

## Описание

Это многофункциональный проект, разработанный для генерации диалогов и синтеза речи. Он использует Python для серверной логики и Unity для клиентской части.

### Основные части приложения

1. **Генерация Диалогов**: Использует файлы `default.yaml`, `story_generator.py` и `topic_generator.py` для создания динамических тем для сценариев.
2. **Синтез Речи**: Файлы в каталоге `services/voice/` отвечают за генерацию речи из текста.
3. **Unity Frontend**: файлы в каталоге `UnityScripts` обеспечивает взаимодействие между клиентом на Unity и сервером на Python.

## Структура файлов

```text
.
├── config/
│   ├── base/
│   │   ├── default.yaml
│   ├── custom/
│   │   ├── custom.yaml
├── models/
│   ├── config.py
│   ├── model_configuration.py
│   ├── story_model.py
│   ├── topic.py
│   ├── topic_type.py
├── repos/
│   ├── story_repository.py
│   ├── topic_repository.py
├── services/
│   ├── voice/
│   │   ├── silero/
│   │   │   ├── silero_tts_generator.py
│   │   ├── base_tts.py
│   │   ├── silero_tts.py
│   │   ├── translit.py
│   │   ├── yandex_tts.py
│   ├── openai.py
│   ├── story_generator.py
│   ├── topic_generator.py
├── UnityScripts/
│   ├── CharacterBehaviour.cs
│   ├── DynamicCamera.cs
│   ├── ScenarioManager.cs
│   ├── StoryModel.cs
├── docker-compose.yml
├── main.py
├── README.md
├── requirements.txt
├── story_controller.py
```

## Описание файлов

- `main.py`: Точка входа для приложения на Python. Здесь инициализируется Flask-приложение и запускаются основные процессы.
- `ScenarioManager.cs`: Точка входа для приложения на C# (Unity). Этот файл обеспечивает взаимодействие между Unity и сервером на Python.
- `story_generator.py`: Содержит базовые функциональности, используемые для генерации диалогов и других задач.
- `topic_generator.py`: Генерирует участников и темы для диалогов на основе заданных параметров из `default.yaml`.
- `default.yaml`: Этот файл содержит системный промпт, параметры и настройки для генерации диалогов и озвучиванию. В нём определяются персонажи и их характеристики, а также стиль диалога.
Пример темы для диалога: `Сенди, Мистер Крабс смеются что Сквидвард осознает себя как часть большой системы`

### Добавление новых конфигураций

Для добавления новых конфигураций создайте новый файл `.yaml` в каталоге `config/custom/` (как базовый пример можно скопировать из каталога `config/base/default.yaml`) и обновите его в соответствии с вашими требованиями.

## Конфигурация .env файла

В проекте используется `.env` файл для управления различными настройками. В этом файле можно указать следующие переменные окружения:

### Общие переменные

- `OPENAI_API_KEY`: Ключ API для доступа к OpenAI. Если используете бесплатные провайдеры, можете указать что угодно
- `OPENAI_API_BASE`: Базовый URL для OpenAI API. Можете указать любой совместимый с `chat/competition` API от open.ai.

### Yandex TTS

- `YANDEX_TTS_API_KEY`: Ключ API для доступа к Yandex TTS.

### Другие настройки

- `CONFIG_NAME`: Имя конфигурационного файла, который должен быть использован.

Пример содержимого `.env` файла:

```
OPENAI_API_KEY=qwe-123
OPENAI_API_BASE=http://127.0.0.1:1337
YANDEX_TTS_API_KEY=qwe-123
CONFIG_NAME=default
```

**Внимание**: Не коммитте `.env` файл в публичные репозитории. Это может компрометировать ваши ключи и токены.

## Установка и запуск

### Вручную

1. Установите необходимые зависимости:

```bash
pip install -r requirements.txt
```

1. Запустите приложение:

```bash
python main.py
```

### Использование Docker

1. Соберите и запустите Docker-контейнер:

```bash
docker-compose up
```

### Скрипт для Unity (Main.cs)

1. Импортируйте все файлы из каталога `UnityScripts` в ваш проект Unity.
2. Убедитесь, что все настройки и зависимости настроены правильно.
3. Проверьте URL сервера Python в настройках Unity.
4. Запустите сцену, в которой используется `ScenarioManager.cs`.

## Переменные окружения

Файл `.env` содержит необходимые переменные окружения для проекта. Убедитесь, что вы обновили этот файл своими учетными данными и настройками.

## Как это работает

### Генерация диалогов

Скрипт начинает свою работу с загрузки конфигурационного файла `default.yaml`. В этом файле содержатся настройки, которые определяют структуру и содержание будущих диалогов. Скрипт создаёт список возможных тем для диалога с участниками и сохраняет их в базу данных. 

Далее, скрипт выбирает первую тему из списка и, используя системный промпт, отправляет запрос на API OpenAI для получения готового диалога. Этот API можно настроить в файле `.env`, изменив базовый адрес API на любой совместимый с `chat/competition` API от open.ai.

#### Пример диалога

```text
Губка Боб::Эй, ребята, я хотел спросить, куда мы отправимся сегодня?
Мистер Крабс::Я думаю, вы сейчас уйдёте отсюда и я стану еще богаче.
Сенди::Ах, Мистер Крабс, ты только о деньгах думаешь.
Сквидвард::Ооо, Мистер Крабс, смотри, Губка Боб готовится получить по лицу лопатой!
Губка Боб::Что? Почему вы мне хотите нанести тяжелую рану? Я же всего лишь хотел узнать, что мы будем делать сегодня.
Мистер Крабс::Никто не хочет тебе нанести рану, Губка Боб. Это просто наша агрессия проявляется по неизвестной причине.
Губка Боб::Эй, ребята, давайте просто забудем об этом и будем дружить, как мы всегда делаем!
Сквидвард::Ну, Губка Боб, если тебя это так волнует, давай пойдем вместе искать новые приключения!
Мистер Крабс::Ты действительно думаешь, что я просто забуду о всех своих деньгах? Hикогда, Губка Боб, и ни с кем!
Сенди::Ох, Мистер Крабс, неужели деньги так важны для тебя? Ведь есть такие вещи, которые нельзя купить за деньги...
```

### Озвучивание и создание сценария

После получения диалога, скрипт разделяет его на отдельные строки и отправляет их на озвучивание. Затем озвученные файлы складываются в каталог `audio` а сценарий с списком диалогов сохраняется в базу данных.

### Отдача контента

При запуске генерации сценариев также запускается веб-сервер с следующими функциями:

- `GET /story/getStory`: Получение сценария.
- `GET /audio/<path:audio_path>`: Получение аудиофайлов
- `DELETE /delete/<string:story_id>`: Удаление сценария.

### Скрипт для Unity

Скрипт в Unity обращается к веб-серверу для получения сценария. После этого начинается последовательное воспроизведение аудио, и камера в Unity переключается на модель персонажа, устанавливается текст в текстовый объект, в соответствии с текстовым сценарием.

По завершении сценария, отправляется запрос на его удаление и скрипт запускает заставку на 5 секунд, отделяя таким образом один сценарий от другого, и процесс повторяется.

В случае, если сервер не может предоставить новый сценарий, скрипт переводит сцену в режим ожидания на 30 секунд и повторяет запрос.

## Поддерживаемые TTS Сервисы

### Silero TTS

- **Поддерживаемые голоса**: 'aidar', 'baya', 'eugene', 'kseniya', 'xenia', 'random'

### Yandex TTS

- **Поддерживаемые голоса**: 'jane', 'ermil', 'zahar', 'alyss'

## Реализация Собственного TTS Сервиса

Если вы хотите добавить свой собственный TTS сервис, вам нужно будет следовать определенному интерфейсу и реализовать несколько методов.

### Интерфейс `BaseTTS`

Каждый новый TTS сервис должен наследовать от базового класса `BaseTTS`. В этом классе есть два ключевых элемента, которые нужно реализовать:

1. **SUPPORTED_VOICES**: Список поддерживаемых голосов. Это должен быть список строк, каждая из которых является идентификатором голоса.

2. **generate_voice(text, voice_id, pos)**: Метод для генерации голоса. Этот метод принимает текст, идентификатор голоса и позицию для генерации аудио. 

Пример реализации может выглядеть следующим образом:

```python
from .base_tts import BaseTTS

class CustomTTS(BaseTTS):
    SUPPORTED_VOICES = ['custom_voice_1', 'custom_voice_2']

    def generate_voice(self, text, voice_id, pos):
        # Your implementation here
```

После реализации этих методов и атрибутов, ваш TTS сервис будет полностью совместим с текущей архитектурой.